{
    "contents" : "#' Nonlinear Least Squares Parameter Estimation\n#' \n#' Determines nonlinear least-squares estimates marketing-mix model\n#' \n#' @param dep.var Dependent variable\n#' @param indp.vars List of variable names to be tried\n#' @param min.adstock An optional list as a numeric vector of minimum adstock for each \\code{indep.vars}\n#' @param max.adstock An optional list as a numeric vector of maximum adstock for each \\code{indep.vars}\n#' @param keep.vars An optional list of variable names that will be kept in each model. \\code{keep.vars} must be part of \\code{indep.vars}\n#' @param transform TBD\n#' @param data A dataset from in which to evaluate the \\code{indp.vars}\n#' @param algorithm Character string specifying the algorithm to use. Only \"LM\" based on Levenberg-Marquardt and \"port\" algorithms are implented.\n#' @param cvTrials A list of logicals to indicate which variable are part of training data. MMR.Optim will repeat for every elements of \\code{cvTrials}\n#' @param indp.vars.try Number of variables randomly sample as independant variables in each \\code{cvTrials} trials\n#' \n#' @details\n#' MMR.Optim determines the nonlinear least-squares estimates of marketing-mix model using optimization techniques such as nls & nlsLM. \n#' The current functionality, for now, focuses on estimating the adstock effect with future plans to also determine dimensioning returns using power transformation or something alike.\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \nMMR.Optim <- function(dep.var,\n                      indp.vars=character(),\n                      min.adstock,\n                      max.adstock,\n                      keep.vars=character(), \n                      transform=character(),\n                      data, \n                      algorithm=\"LM\", \n                      cvTrials,\n                      indp.try =length(indp.vars)-length(keep.vars)) {\n    # Error checking\n    if(missing(dep.var))\n        stop(\"Argument 'dep.var' is missing.\")\n    \n    if(length(indp.vars)==0)\n        stop(\"No indpendent variable(s) to try.\")\n    \n    if(missing(data))\n        stop(\"Argument 'data' is missing.\")\n\n    if(!exists(deparse(substitute(data))))\n        stop(\"The dataset '\", deparse(substitute(data)), \"' doesn't exists.\")\n    \n    if(sum(!(c(dep.var, indp.vars) %in% names(data))))\n        stop(\"The following variable(s) are not part of '\", deparse(substitute(data)), \"' dataset:\\n\",\n             paste(c(dep.var, indp.vars)[!(c(dep.var, indp.vars) %in% names(data))], collapse=\", \"))\n\n    if(!missing(min.adstock)) {\n        if(sum(!(names(min.adstock) %in% indp.vars))) {\n            stop(\"The following 'min.adstock' variable(s) are not part of 'indp.vars':\\n\",\n                 paste(names(min.adstock)[!(names(min.adstock) %in% indp.vars)], collapse=\", \"))\n        } else if(sum(!(indp.vars %in% names(min.adstock)))) {\n            min.adstock.add <- rep(0, length(indp.vars) - length(min.adstock))\n            names(min.adstock.add) <- indp.vars[!(indp.vars %in% names(min.adstock))]\n            min.adstock <- c(min.adstock, min.adstock.add)\n        }\n    }\n    if(!missing(max.adstock)) {\n        if(sum(!(names(max.adstock) %in% indp.vars))) {\n            stop(\"The following 'max.adstock' variable(s) are not part of 'indp.vars':\\n\",\n                 paste(names(max.adstock)[!(names(max.adstock) %in% indp.vars)], collapse=\", \"))\n        } else if(sum(!(indp.vars %in% names(max.adstock)))) {\n            max.adstock.add <- rep(0.99, length(indp.vars) - length(max.adstock))\n            names(max.adstock.add) <- indp.vars[!(indp.vars %in% names(max.adstock))]\n            max.adstock <- c(max.adstock, max.adstock.add)\n        }\n    }\n    \n    if(missing(min.adstock)) {\n        min.adstock <- rep(0, length(indp.vars))\n        names(min.adstock) <- indp.vars\n    }\n    if(missing(max.adstock)){\n        max.adstock <- rep(.99, length(indp.vars))\n        names(max.adstock) <- indp.vars\n    }\n    \n    if(length(transform)) {\n        if(sum(!(names(transform) %in% indp.vars))) {\n            stop(\"The following 'transform' variable(s) are not part of 'indp.vars':\\n\",\n                 paste(names(transform)[!(names(transform) %in% indp.vars)], collapse=\", \"))\n        }\n        \n        transform <- tolower(transform)\n        if(sum(!(transform %in% c(\"power\", \"powerinv\", \"log\", \"negexp\")))) {\n            stop(\"The following transformation(s) are not recognized:\\n\",\n                 paste(as.character(transform[!(transform %in% c(\"power\", \"powerinv\", \"log\", \"negexp\"))]), collapse = \", \"),\n                 \"\\n\\nOnly {'Power', 'PowerInv', 'Log', 'NegExp'} are allowed.\")\n        }\n    }\n    \n    # Cross-validation trials\n    if(missing(cvTrials)){\n        cvTrials <- lapply(createInTrainFolds(data, k=1), function(x) !x)\n    }\n        \n    # Run optimizations over trials & extract parameters coefficients\n    optm.LM <-\n        mclapply(cvTrials, \n                 FUN= function(inTrain){\n                     indp.in <- indp.try\n                     if(class(indp.try)==\"function\")\n                         indp.in <- indp.try()\n                     indp.in <- min(max(indp.in, 0), length(indp.vars)-length(keep.vars))\n\n                     # Run optimization\n                     optmFit <- MMR.Optim.InTrain(dep.var,\n                                                  indp.vars,\n                                                  min.adstock,\n                                                  max.adstock,\n                                                  keep.vars, \n                                                  transform,\n                                                  data, \n                                                  algorithm,\n                                                  inTrain,\n                                                  indp.in)})\n}\n\n\n#' Nonlinear Least Squares Parameter Estimation\n#' \n#' Determines nonlinear least-squares estimates marketing-mix model for a single trial.\n#' \n#' @param dep.var Dependent variable\n#' @param indp.vars List of variable names to be tried\n#' @param min.adstock An optional list as a numeric vector of minimum adstock for each \\code{indp.vars}\n#' @param max.adstock An optional list as a numeric vector of maximum adstock for each \\code{indp.vars}\n#' @param keep.vars An optional list of variable names that will be kept in each model. \\code{keep.vars} must be part of \\code{indep.vars}\n#' @param transform TBD\n#' @param data A dataset from in which to evaluate the \\code{indp.vars}\n#' @param algorithm The algorithm to use {\"LM\", \"port\"}\n#' @param inTrain A logical list indicating which observations are used for training\n#' @param indp.try A positive decimal to indicate the probability of including all random.vars\n#' \n#' @examples\n#' \\donttest{MMR.Optim.InTrain(\"sales\", c(\"Trend\", \"Season\"), c(\"ad1\", \"ad2\", \"ad3\"), ad.data, sample(c(T, F), nrow(ad.data)))}\n#' \nMMR.Optim.InTrain <- function(dep.var, \n                              indp.vars,\n                              min.adstock,\n                              max.adstock,\n                              keep.vars, \n                              transform,\n                              data, \n                              algorithm, \n                              inTrain,\n                              indp.try) {\n    ## QA\n    #cat(\"indp.vars: \"); cat(indp.vars)\n    #cat(\"\\nkeep.vars: \"); cat(keep.vars)\n    #cat(\"\\n\\n\")\n    \n    # Determine which variable is present in data for the given inTrain sample\n    inTrainSum <- rowsum(data[, indp.vars[indp.vars %in% names(data)], drop=F], inTrain)\n    \n    if(!(\"TRUE\" %in% rownames(inTrainSum))) {\n        present.vars <- character()\n        \n    } else {\n        inTrainSum <- t(inTrainSum)[,\"TRUE\", drop=F]\n        ## QA\n        #print(inTrainSum)\n        #print(\"\")\n        present.vars <- rownames(inTrainSum)#[inTrainSum > 0]\n    }\n    \n    keep.vars <- present.vars[ (present.vars %in% keep.vars)]\n    temp.vars <- present.vars[!(present.vars %in% keep.vars)]\n    \n    ## QA\n    #cat(\"present.vars: \"); cat(present.vars)\n    #cat(\"\\nkeep.vars: \"); cat(keep.vars)\n    #cat(\"\\ntemp.vars: \"); cat(temp.vars)\n    #cat(\"\\n\\n\")\n    \n    # Randomly select variables from present; keep the keep.vars\n    select.vars <- sample(temp.vars, min(indp.try, length(temp.vars)), F)\n    model.vars  <- c(keep.vars, select.vars)\n    model.vars  <- model.vars[order(match(model.vars, indp.vars))]\n\n    ## QA\n    #cat(\"model.vars: \"); cat(model.vars) \n    #cat(\"\\n\\n\")\n    \n    # Get parameters starting, min & max values\n    if(sum(length(model.vars))==0) {\n        formula0 <- paste(dep.var, \"~\", \"1\")\n    } else {\n        formula0 <- paste(dep.var, \"~\", \n                          paste(model.vars, collapse=\" + \"))\n    }\n    \n    modFit0 <- lm(formula0, data=data[inTrain, ])\n    \n    ## QA\n    #cat(\"formula0:  \"); cat(formula0)\n    #print(modFit0)\n    #cat(\"\\n\\n\")\n    \n    coef.start <- coef(modFit0)\n    coef.NA    <- names(coef.start[is.na(coef.start)])\n    \n    coef.start <- coef.start[!(names(coef.start) %in% coef.NA)]\n    coef.min   <- rep(-Inf, length(coef.start))\n    coef.max   <- rep( Inf, length(coef.start))\n    \n    ## QA\n    #cat(\"NA coef.start: \\n\")\n    #print(coef.start[is.na(coef.start)])\n    #cat(\"\\n\")\n    \n    if(length(coef.start)==1) {\n        names(coef.start) <- c(\"Intercept\")\n    } else {\n        names(coef.start) <- c(\"Intercept\", \n                               paste0(names(coef.start)[2:(length(coef.start))], \n                                      \".coef\"))        \n    }\n    names(coef.min  ) <- names(coef.start)\n    names(coef.max  ) <- names(coef.start)\n\n    ## QA\n    #cat(\"min.adstock: \"); print(min.adstock)\n    #cat(\"max.adstock: \"); print(max.adstock)\n    #cat(\"\\n\\n\")\n    \n    # Split model vars into fixed.vars & random.vars\n    model.vars  <- model.vars[!(model.vars %in% coef.NA)]\n    fixed.vars  <- model.vars[min.adstock[model.vars]==max.adstock[model.vars]]\n    random.vars <- model.vars[min.adstock[model.vars]!=max.adstock[model.vars]]\n    \n    # Order variables\n    fixed.vars  <- fixed.vars [order(match(fixed.vars , indp.vars))]\n    random.vars <- random.vars[order(match(random.vars, indp.vars))]\n    \n    ## QA\n    #cat(\"fixed.vars: \"); cat(fixed.vars) \n    #cat(\"\\nrandom.vars: \"); cat(random.vars) \n    #cat(\"\\n\\n\")\n\n    adstocks.start <- min.adstock[random.vars]\n    adstocks.min   <- min.adstock[random.vars]\n    adstocks.max   <- max.adstock[random.vars]\n    \n    ## QA\n    #print(length(adstocks.start))\n    \n    if(length(adstocks.start)) {\n        names(adstocks.start) <- paste0(names(adstocks.start), \".adstock\")\n        names(adstocks.min  ) <- paste0(names(adstocks.min  ), \".adstock\")\n        names(adstocks.max  ) <- paste0(names(adstocks.max  ), \".adstock\")\n    }\n    \n    transform.start <- transform[(names(transform) %in% c(fixed.vars, random.vars)) & !(transform %in% \"log\")]\n    transform.min <- rep(-Inf, length(transform.start))\n    transform.max <- rep( Inf, length(transform.start))\n    if(length(transform.start)) {\n        transform.start <- sapply(transform.start, \n                                  function(x) {\n                                      if(tolower(x)==\"power\") {\n                                          1\n                                      } else if(tolower(x)==\"powerinv\") {\n                                          0\n                                      } else if(tolower(x)==\"negexp\") {\n                                          1\n                                      }\n                                  })\n\n        transform.min <- rep(-Inf, length(transform.start))\n        transform.max <- rep( Inf, length(transform.start))\n        \n        names(transform.start) <- paste0(names(transform.start), \".power\")\n        names(transform.min  ) <- paste0(names(transform.start), \".power\")\n        names(transform.max  ) <- paste0(names(transform.start), \".power\")\n    } else {\n        transform.start <- numeric()\n    }\n    \n    nls.start <- c(coef.start, adstocks.start, transform.start)\n    nls.min   <- c(coef.min  , adstocks.min  , transform.min)\n    nls.max   <- c(coef.max  , adstocks.max  , transform.max)\n      \n    ## QA\n    #cat(\"\\nnls.start: \\n\"); print(nls.start)\n    #cat(\"\\nnls.min:   \\n\"); print(nls.min  )\n    #cat(\"\\nnls.max:   \\n\"); print(nls.max  )\n    #cat(\"\\n\")\n\n    # Build formula\n    formula2 <- MMR.Optim.Formula(dep.var, fixed.vars, min.adstock[fixed.vars], random.vars, transform)\n\n    ## QA\n    #cat(\"formula2: \\n\"); cat(formula2)\n    \n    data$inTrain <- inTrain\n    \n    ## QA\n    #cat(\"\\n-----------------------------------------------------------------------\")\n    #cat(\"\\n-----------------------------------------------------------------------\\n\\n\")\n\n    # Run optimization\n    if(algorithm==\"port\") {\n        try(nls(formula2,\n                data      = data, \n                algorithm = \"port\", \n                start     = nls.start, \n                lower     = nls.min, \n                upper     = nls.max,\n                model     = T,\n                control   = nls.control(maxiter=500)),\n            silent = T)\n    } else {\n        try(nlsLM(formula2,\n                  data      = data, \n                  algorithm = \"LM\", \n                  start     = nls.start, \n                  lower     = nls.min, \n                  upper     = nls.max,\n                  model     = T,\n                  control   = nls.lm.control(maxiter=500)),\n            silent = F)\n    }\n}\n\n\n#' Write Optim Formula\n#' \n#' Writes the inTrain formula such as \"sales ~ inTrain * (Trend + ad1)\n#' \n#' @param dep.var A numeric vector\n#' @param fixed A character vector of variable names that won't be adstocked\n#' @param fixed.adstocked A numeric vector same length as \\code{fixed}\n#' @param random A character vector of variable names to be adstocked\n#' \n#' @author Gabriel Mohanna\n#' \nMMR.Optim.Formula <- function(dep.var, \n                              fixed=character(), \n                              fixed.adstock=rep(0, length(fixed)),\n                              random=character(),\n                              transform=character()) {\n    # Apply adstock transformations\n    fixed <- mapply(\n        function(var.name, var.value) {\n            if(var.value) {\n                paste0(\"adstock(\", var.name, \", \", var.value, \")\")\n            } else {\n                paste0(var.name)\n            }\n        },\n        fixed, fixed.adstock,\n        SIMPLIFY = F)\n    \n    random <- mapply(\n        function(var.name) {\n            paste0(\"adstock(\", var.name, \", \", var.name, \".adstock)\")\n        },\n        random,\n        SIMPLIFY = F)\n    \n    adstock.transfrom <- append(fixed, random)\n    \n    # Apply other functional transformations were they apply\n    other.transform <- mapply(\n        function(var.name, var.adstock) {\n            if(var.name %in% names(transform)) {\n                var.transform <- transform[var.name]\n                if(var.transform==\"power\") {\n                    paste0(var.name, \".coef*(\", var.adstock, \"^\", var.name, \".power)\")\n                } else if(var.transform==\"negexp\") {\n                    paste0(var.name, \".coef*\", \"(1 - exp(-\", var.name, \".power * \", var.adstock, \"))\")\n                } else if(var.transform==\"log\") {\n                    paste0(var.name, \".coef*\", \"log(1+\", var.adstock, \")\")\n                } else if(var.transform==\"powerinv\") {\n                    paste0(var.name, \".coef/\", \"(\", var.name, \".power + 1/\", var.adstock, \")\")\n                }\n            } else {\n                paste0(var.name, \".coef*\", var.adstock)\n            }\n        },\n        names(adstock.transfrom), adstock.transfrom,\n        SIMPLIFY = F)\n    \n    paste0(dep.var, \" ~ \",\n           \"inTrain * (Intercept\", \n           paste(rep(\" +\", length(other.transform)), other.transform, collapse = \"\"),\n           \")\")\n}\n\n\n#' Model Prediction\n#' \n#' Predicts \n#' \n#' @param object An MMR.Optim object for which prediction is desired\n#' @param newdata something\n#' @param combine A logical to indicate if all predictions to be combined\n#' @param combineMethod A character of {\"mean\", \"MAPE\", \"MSE\", \"RMSE\"}\n#' @param combineTest A logical to indicate to use inTest observations\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \nMMR.Predict <- function(MMR.object, \n                        newdata,\n                        combine=TRUE,\n                        combineMethod=\"MSE\",\n                        combineTest=TRUE){\n    if(!(combineMethod %in% c(\"mean\", \"MAPE\", \"MSE\", \"RMSE\"))){\n        stop(\"'combineMethod' can only be {'mean', 'MAPE', 'MSE', or 'RMSE'}\")\n    }\n    \n    useExistingData <- missing(newdata)\n    \n    optmFit.predict <- \n        mclapply(MMR.object,\n                 FUN= function(optmFit){\n                     if(class(optmFit) == \"nls\") {\n                         if(useExistingData) {\n                             new.data <- getModeledData(optmFit)\n                         } else {\n                             new.data <- newdata\n                         }\n                         \n                         new.data$inTrain <- rep(T, length(new.data[[1]]))\n                         \n                         predict(optmFit, newdata = new.data)\n                     } else {\n                         NA\n                     }\n                 })\n    \n    if(combine) {\n        # Convert predictions to data frame by trial\n        max.items <- max(sapply(optmFit.predict, length))\n        predictDF <- do.call(cbind.data.frame, \n                             lapply(optmFit.predict, \n                                    function(x) {\n                                        if(sum(is.na(x))) {\n                                            rep(NA, max.items)\n                                        } else {\n                                            x\n                                        }\n                                    }))\n        \n        # Get weights\n        if(combineMethod==\"mean\") {\n            weights <- sapply(optmFit.predict,\n                              function(x) {\n                                  ifelse(sum(is.na(x)), NA, 1)\n                              })\n        } else if(combineMethod==\"MAPE\") {\n            weights <- 1 / getModelErrors(MMR.object, \"MAPE\", training = !combineTest)\n        } else if(combineMethod==\"MSE\") {\n            weights <- 10 / getModelErrors(MMR.object, \"MSE\", training = !combineTest)\n        } else if(combineMethod==\"RMSE\") {\n            weights <- 10 / sqrt(getModelErrors(MMR.object, \"MSE\", training = !combineTest))\n        }\n        \n        # Get OOB indicators\n        #inTrainSamples <- \n        #    mclapply(MMR.object,\n        #             function(nlsObject) {\n        #                 if(class(nlsObject)==\"nls\") {\n        #                     nlsObject$model$inTrain\n        #                 } else {\n        #                     NA\n        #                 }\n        #             })\n        \n        #inTrainDF <- \n        #    do.call(cbind.data.frame, \n        #            lapply(inTrainSamples, \n        #                   function(x) {\n        #                       if(sum(is.na(x))) {\n        #                           rep(NA, max.items)\n        #                       } else {\n        #                           ifelse(x, 0, 1)\n        #                       }\n        #                   }))\n\n        # Calculate weighted mean\n        rowSums(predictDF * matrix(weights, nrow(predictDF), \n                                   ncol = ncol(predictDF), \n                                   byrow = T), \n                na.rm=T) / sum(weights, na.rm=T)\n    } else {\n        optmFit.predict\n    }\n}\n\n\n#' Returns data used in optimization\n#' \n#' Returns data used in optimization without inTrain or intercept\n#' \n#' @param nlsObject An nls object.\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \ngetModeledData <- function(nlsObject) {\n    new.data  <- nlsObject$model\n    notDataNames <- c(names(new.data[1]), \"inTrain\", names(coef(nlsObject)))\n    dataNames <- names(new.data[!(names(new.data) %in% notDataNames)])\n    new.data[dataNames]\n}\n\n\n#' Prints Coefficient Estimates for MMR.Optim\n#' \n#' Summarize the coefficient values for MMR.Optim\n#' \n#' @param object An MMR.Optim object for which extraction of model coeeficients is meaningful\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \nMMR.Coef <- function(object) {\n    #Extract optimized parameters estimates\n    optmFit.DF <- \n        mclapply(object,\n                 FUN= function(optmFit) {\n                     # Extract optimizated parameters cofficients\n                     if(class(optmFit) == \"nls\") {\n                         inTrain <- optmFit$model$inTrain\n                         \n                         new.data <- getModeledData(optmFit)\n                         \n                         # optmFit$model[[1]] is the first element in the model data frame and contains the dependant variable\n                         new.data$inTrain <- inTrain\n                         MSE.train  <- NA\n                         MAPE.train <- NA\n                         if(sum(inTrain)){\n                             predicted  <- predict(optmFit, newdata= new.data)\n                             MSE.train  <- sum(((optmFit$model[[1]] - predicted)* inTrain)^2)/sum(inTrain)\n                             MAPE.train <- sum(abs(predicted/optmFit$model[[1]]-1)*inTrain)/sum(inTrain)\n                         }\n                         \n                         new.data$inTrain <- !inTrain\n                         MSE.test  <- NA\n                         MAPE.test <- NA\n                         if(sum(!inTrain)) {\n                             predicted <- predict(optmFit, newdata= new.data)\n                             MSE.test  <- sum(((optmFit$model[[1]] - predicted)*!inTrain)^2)/sum(!inTrain)\n                             MAPE.test <- sum(abs(predicted/optmFit$model[[1]]-1)*!(inTrain))/sum(!inTrain)\n                         }\n                         \n                         optmFit.return <- c(coef(optmFit), MSE.train, MSE.test, MAPE.train, MAPE.test)\n                         optmFit.DF <- data.frame(Param=c(names(coef(optmFit)), \"MSE.train\", \"MSE.test\", \"MAPE.train\", \"MAPE.test\"),\n                                                  optmFit=optmFit.return)\n                         names(optmFit.DF)[2] <- paste0(\"optmFit\", sample(1:1000000, 1))\n                     } else {\n                         optmFit.DF <- data.frame(Param=c(\"MSE.train\", \"MSE.test\", \"MAPE.train\", \"MAPE.test\"), optmFit=NA)\n                         names(optmFit.DF)[2] <- paste0(\"optmFit\", sample(1:1000000, 1))\n                     }\n                     \n                     optmFit.DF\n                 })\n    \n    # Convert list of optimizations into data frame\n    if(length(optmFit.DF)) {\n        optmFit.DF <- Reduce(function(x, y) merge(x, y, by=\"Param\", all=T), optmFit.DF)\n    } else {\n        optmFit.DF <- optmFit.DF$fold1\n    }\n    names(optmFit.DF) <- c(\"Param\", names(object))\n    \n    ## Sort parameters data frame\n    #coef.order <- c(\"Intercept\", \n    #                paste0(c(fixed.vars, random.vars), \".coef\"), \n    #                paste0(random.vars, \".adstock\"),\n    #                c(\"rss.train\", \"rss.test\"))\n    \n    #optm.LM <- optm.LM[order(match(optm.LM$Param, coef.order)), ]\n    \n    # Return file optimized parameters data frame\n    optmFit.DF\n}\n\n\n#' MMR.Coef.Plot\n#' \n#' Some description\n#' \n#' @param object An MMR.Optim object for which extraction of model coeeficients is meaningful\n#' @param Param A character vector or one or more variables on which adstock is to be plotted\n#' @param y A character of {\"mean\", \"MAPE\", \"MSE\", \"RMSE\"}\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \nMMR.Coef.Plot <- function(object, \n                          Param, \n                          y) {\n    if(missing(object))\n        stop(\"Argument \\\"object\\\" is missing.\")\n    if(missing(Param))\n        stop(\"Argument \\\"Param\\\" is missing.\")\n    if(!missing(y) && !(y %in% c(\"MAPE\", \"MSE\", \"RMSE\")))\n        stop(\"Argument \\\"y\\\" can only be 'MAPE', 'MSE', 'or RMSE'.\")\n    \n    MMR.Coef <- MMR.Coef(object)\n    \n    if(sum(grepl(\"\\\\.coef$\", MMR.Coef$Param))) {\n        MMR.Coef <- MMR.Coef(object)\n        Adstock <- melt(MMR.Coef[grepl(\"\\\\.coef$\", MMR.Coef$Param), ], id.vars=\"Param\", variable.name = \"Trial\", value.name = \"Adstock\")\n        \n        if(missing(y)) {\n            Adstock$Param <- sub(\"\\\\.coef$\", \"\", Adstock$Param)\n            Adstock <- Adstock[order(Adstock$Param),]\n            Adstock <- Adstock[complete.cases(Adstock),]\n            Adstock <- Adstock[Adstock$Param %in% Param, ]\n            \n            unique.Param <- unique(Adstock$Param)\n            Adstock$Param <- factor(Adstock$Param,levels = unique.Param[order(unique.Param, decreasing = T)])\n            ggplot(Adstock, aes(Param, Adstock)) + \n                geom_boxplot() + coord_flip() + \n                xlab(\"Param\") + ylab(\"Coefficient\") + ggtitle(\"Coefficients\") +\n                theme_bw() + theme(plot.title = element_text(size=16, face=\"bold\", vjust=2),\n                                   axis.title.x = element_text(vjust=-0.35))\n        } else {\n            if(y==\"MAPE\") {\n                MAPE.test <- melt(MMR.Coef[grepl(\"MAPE\\\\.test\", MMR.Coef$Param), ], id.vars=\"Param\", variable.name = \"Trial\", value.name = \"MAPE.test\")\n            } else {\n                MAPE.test <- melt(MMR.Coef[grepl(\"MSE\\\\.test\" , MMR.Coef$Param), ], id.vars=\"Param\", variable.name = \"Trial\", value.name = \"MAPE.test\")\n            }\n            \n            if(y==\"RMSE\") \n                MAPE.test$MAPE.test <- sqrt(MAPE.test$MAPE.test)\n            MAPE.test$MAPA <- 1/MAPE.test$MAPE.test\n            \n            Adstock.MAPE <- merge(Adstock, MAPE.test[,-1], by=\"Trial\", all=T)\n            Adstock.MAPE$Param <- sub(\"\\\\.coef$\", \"\", Adstock.MAPE$Param)\n            \n            Adstock.MAPE <- Adstock.MAPE[order(Adstock.MAPE$Param),]\n            Adstock.MAPE <- Adstock.MAPE[complete.cases(Adstock.MAPE),]\n            Adstock.MAPE <- Adstock.MAPE[Adstock.MAPE$Param %in% Param, ]\n            \n            ggplot(Adstock.MAPE, aes(Adstock, MAPA)) + \n                geom_point(alpha=.5) + facet_grid(Param ~ .) + \n                xlab(\"Coefficient\") + ylab(paste0(\"1 / \", y)) + ggtitle(paste0(\"Coefficients vs. 1/\", y)) +\n                theme_bw() + theme(plot.title = element_text(size=16, face=\"bold\", vjust=2),\n                                   axis.title.x = element_text(vjust=-0.35))\n            #+ geom_vline(xintercept = Adstock.MAPE$Adstock[which.max(Adstock.MAPE$MAPA)])\n        }  \n        #ggplot(Adstock.MAPE, aes(MAPA, Adstock)) + geom_boxplot(aes(Adstock)) + geom_point() + coord_flip() + facet_grid(Param ~ .)\n    } else {\n        stop(paste(\"No adstock to show.\"))\n    }\n}\n\n\n#' Adstock Rates Plot\n#' \n#' Some description\n#' \n#' @param object An MMR.Optim object for which extraction of model coeeficients is meaningful\n#' @param Param A character vector or one or more variables on which adstock is to be plotted\n#' @param y A character of {\"mean\", \"MAPE\", \"MSE\", \"RMSE\"}\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \nMMR.Adstock.Plot <- function(object, \n                             Param, \n                             y) {\n    if(missing(object))\n        stop(\"Argument \\\"object\\\" is missing.\")\n    if(missing(Param))\n        stop(\"Argument \\\"Param\\\" is missing.\")\n    if(!missing(y) && !(y %in% c(\"MAPE\", \"MSE\", \"RMSE\")))\n        stop(\"Argument \\\"y\\\" can only be 'MAPE', 'MSE', 'or RMSE'.\")\n    \n    MMR.Coef <- MMR.Coef(object)\n    \n    if(sum(grepl(\"\\\\.adstock$\", MMR.Coef$Param))) {\n        MMR.Coef <- MMR.Coef(object)\n        Adstock <- melt(MMR.Coef[grepl(\"\\\\.adstock$\", MMR.Coef$Param), ], id.vars=\"Param\", variable.name = \"Trial\", value.name = \"Adstock\")\n                \n        if(missing(y)) {\n            Adstock$Param <- sub(\"\\\\.adstock$\", \"\", Adstock$Param)\n            Adstock <- Adstock[order(Adstock$Param),]\n            Adstock <- Adstock[complete.cases(Adstock),]\n            Adstock <- Adstock[Adstock$Param %in% Param, ]\n            \n            unique.Param <- unique(Adstock$Param)\n            Adstock$Param <- factor(Adstock$Param,levels = unique.Param[order(unique.Param, decreasing = T)])\n            ggplot(Adstock, aes(Param, Adstock)) + \n                geom_boxplot() + ylim(0, 1) + coord_flip() + \n                xlab(\"Param\") + ylab(\"Adstock\") + ggtitle(\"Adstock Rates Boxplot\") +\n                theme_bw() + theme(plot.title = element_text(size=16, face=\"bold\", vjust=2),\n                                   axis.title.x = element_text(vjust=-0.35))\n        } else {\n            if(y==\"MAPE\") {\n                MAPE.test <- melt(MMR.Coef[grepl(\"MAPE\\\\.test\", MMR.Coef$Param), ], id.vars=\"Param\", variable.name = \"Trial\", value.name = \"MAPE.test\")\n            } else {\n                MAPE.test <- melt(MMR.Coef[grepl(\"MSE\\\\.test\" , MMR.Coef$Param), ], id.vars=\"Param\", variable.name = \"Trial\", value.name = \"MAPE.test\")\n            }\n\n            if(y==\"RMSE\") \n                MAPE.test$MAPE.test <- sqrt(MAPE.test$MAPE.test)\n            MAPE.test$MAPA <- 1/MAPE.test$MAPE.test\n            \n            Adstock.MAPE <- merge(Adstock, MAPE.test[,-1], by=\"Trial\", all=T)\n            Adstock.MAPE$Param <- sub(\"\\\\.adstock$\", \"\", Adstock.MAPE$Param)\n            \n            Adstock.MAPE <- Adstock.MAPE[order(Adstock.MAPE$Param),]\n            Adstock.MAPE <- Adstock.MAPE[complete.cases(Adstock.MAPE),]\n            Adstock.MAPE <- Adstock.MAPE[Adstock.MAPE$Param %in% Param, ]\n            \n            ggplot(Adstock.MAPE, aes(Adstock, MAPA)) + \n                geom_point(alpha=.5) + facet_grid(Param ~ .) + \n                ylab(paste0(\"1 / \", y)) + ggtitle(paste0(\"Adstock Rates vs. 1/\", y)) + xlim(0, 1) +\n                theme_bw() + theme(plot.title = element_text(size=16, face=\"bold\", vjust=2),\n                                   axis.title.x = element_text(vjust=-0.35))\n            #+ geom_vline(xintercept = Adstock.MAPE$Adstock[which.max(Adstock.MAPE$MAPA)])\n        }  \n        #ggplot(Adstock.MAPE, aes(MAPA, Adstock)) + geom_boxplot(aes(Adstock)) + geom_point() + coord_flip() + facet_grid(Param ~ .)\n    } else {\n        stop(paste(\"No adstock to show.\"))\n    }\n}\n\n\n#' Calculates Model Error\n#' \n#' Some description\n#' \n#' @param MMR.object An MMR.Optim object for which extraction of models error is meaningful\n#' @param type A character of {\"MSE\", \"MAPE\"}\n#' @param training A logical to indicate inTrain vs. inTest\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \ngetModelErrors <- function(MMR.object, type=\"MSE\", training=T) {\n    if(!(type %in% c(\"MSE\", \"MAPE\")))\n        stop(paste0(\"Argument type = '\", type, \"' is not recognized.\"))\n    \n    sapply(MMR.object,\n           function(nlsObject) {\n               errorVal <- NA\n               \n               if(class(nlsObject)==\"nls\") {\n                   if(training) {\n                       inTrain <- nlsObject$model$inTrain\n                   } else {\n                       inTrain <- !nlsObject$model$inTrain\n                   }\n                   new.data <- getModeledData(nlsObject)\n                   \n                   if(sum(inTrain)) {\n                       new.data$inTrain <- inTrain\n                       actual <- nlsObject$model[[1]]\n                       predicted <- predict(nlsObject, newdata=new.data)\n                       \n                       if(type==\"MSE\") {\n                           errorVal <- sum(((actual - predicted)*inTrain)^2)/sum(inTrain)\n                       } else if(type==\"MAPE\") {\n                           errorVal <- sum(abs(predicted / actual - 1)*inTrain)/sum(inTrain)\n                       }\n                   }\n               }\n               \n               errorVal\n           },\n           simplify=T)\n}\n\n\n#' Returns a Data Frame for a List\n#' \n#' Returns a Data Frame for a List of Single Vectors\n#' \n#' @param mylist A list of single vecors\n#' \n#' @author Gabriel Mohanna\n#' \n#' @export\n#' \nlist2df <- function(mylist) {\n    max.items <- max(sapply(mylist, length))\n    \n    do.call(cbind.data.frame, \n            lapply(mylist, \n                   function(x) {\n                       if(sum(is.na(x))==1) {\n                           rep(NA, max.items)\n                       } else {\n                           x\n                       }\n                   }))\n}\n",
    "created" : 1415642782241.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "905103975",
    "id" : "F013BB53",
    "lastKnownWriteTime" : 1415817760,
    "path" : "C:/Users/gmohanna/OneDrive/Work Files/R Libraries/MMR/R/MMR.R",
    "project_path" : "R/MMR.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}